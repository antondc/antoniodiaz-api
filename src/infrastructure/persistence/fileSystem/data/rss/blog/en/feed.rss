<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="YOUR-WEBSITE/feed.rss" rel="self" type="application/rss+xml"/><title>YOUR-WEBSITE-TITLE</title><link>YOUR-WEBSITE/</link><description>YOUR-WEBSITE-DESCRIPTION</description><language>en-US</language><item><title>My New Article</title><pubDate>Mon, 19 Jan 1970 21:00:00 GMT</pubDate><guid isPermaLink="true">YOUR-WEBSITE/1/</guid><description><![CDATA[<p><p>Desde hace algún tiempo Rust ha estado ganando popularidad entre desarrolladores, siendo el lenguaje más apreciado los últimos cinco años según las <a href="https://insights.stackoverflow.com/survey/2021#overview" target="_blank">estadísticas de stackoverflow</a>. Pero otros índices, como el de <a href="https://www.tiobe.com/tiobe-index/" target="_blank">TIOBE</a>, lo posicionan por debajo de los veinte lenguajes más usados. Es además dificil encontrar programadores actualmente trabajando con este lenguaje, o empresas utilizándolo en producción.</p><p>¿Qué significa todo esto? Mientras que Rust es reconocido como una herramienta de valor por parte de la comunidad de desarrolladores, su integración en la industria está requiriendo tiempo, quizás debido a su especialización y particularidades. ¿Por qué, entonces, invertir tiempo en un lenguaje así? ¿Cómo pinta el futuro de Rust? Para responder a todas estas cuestiones echaremos un vistazo al lenguaje, su sintaxis, sus funcionalidades fundamentales y cómo puede ser utilizado para aplicaciones web básicas.</p><h1>Características</h1><p>Rust se originó en el equipo de Mozilla como el proyecto personal de uno de sus desarrolladores, Graydon Hoare. Desde entonces ha evolucionado hasta convertirse en un proyecto soportado por una amplia comunidad de programadores, con la <a href="https://foundation.rust-lang.org/" target="_blank">Rust Foundation</a> como sus principal órgano de gobierno.</p><p>Tiene algunas características que, juntas, lo hacen diferente a otros lenguajes:</p><ul><li>Es un lenguaje <strong>compilado</strong>.</li><li>Es de <strong>tipado fuerte</strong>.</li><li>Carece de <strong>recolector de basura</strong>, usando un «verificador de préstamos» —«borrow checker»— en su lugar<strong>.</strong></li><li>Provee de <strong>punteros/referencias</strong> para el stack, y<strong> punteros avanzados </strong>para el heap.</li><li>Está concebido tanto para <strong>OOP</strong> como para programación <strong>funcional.</strong></li><li>As <strong>agnóstico respecto del entorno de ejecución asíncrono</strong> que se use.</li><li>Tiene una <strong>suite de tests integrada</strong> en el lenguaje.</li></ul><p>Veamos cada punto para ver qué puede ofrecernos cada característica.</p><p>Siendo un lenguaje compilado, Rust nos ofrecerá gran cantidad de información sobre el uso de memoria de nuestro programa antes de la ejecución del mismo. Haciendo uso de estructuras fuertemente tipadas Rust garantiza que, una vez que el programa compila, es seguro en cuanto a uso de memoria.</p><p>Por supuesto, nosotros los programadores podremos cometer errores de muchas otras maneras, especialmente en cuanto a lógica de negocio se refiere; pero el compilador nos asegura que, estructuralmente, nuestro programa será tan eficiente y coherente como sea posible. </p><p>Esto sucede principalmente por el hecho de que Rust no depende de un sistema de recolección de basura. Lenguajes como Java, Python o Javascript dependen de un recolector de basura para manejar la memoria y eliminar variables que quedan en desuso. En otros lenguajes, como C o C++, se requiere manejar los recursos manualmente; pero en Rust tenemos un «comprobador de préstamos», esto es, un sistema que se asegura <em>en tiempo de ejecución</em> que cuando una variable queda fuera de uso, esta es eliminada.</p><p>Esta funcionalidad es automática para todos los valores cuyo tamaño sea conocido de antemano, almacenándose en el stack. Podemos hacer además uso de punteros al estilo C —<mark>(*&amp;)</mark>— para referenciarlos y deferenciarlos; siempre con algunos límites impuestos por Rust para evitar acciones inseguras con la memoria.</p><p>Para aquellos otros valores cuyo tamaño no es conocido de antemano por el compilador, y que tienen que ser almacenaos en el heap, como por ejemplo los arrays —«vectores» en Rust—, el lenguaje nos ofrecerá estructuras específicas —<mark>Box</mark>, <mark>Rc</mark>, <mark>Arc</mark>, etc.—para envolverlos y asegurar que serán elminados lo más pronto posible.</p><p>Una de las principales funcionalidades de Rust es el retorno a una versión simplificada de las estructuras al estilo C, en oposición a las clases a las que lenguajes como C++ o Java nos tienen acostumbrados. Aquí encontraremos tres términos clave relacionados con estas estructuras:  <mark>struct</mark>, <mark>impl</mark> y <mark>trait</mark>. Podemos definir un nuevo struct con <mark>struct</mark>; después de definirlo, podemos añadirle métodos usando <mark>impl</mark>. Finalmente, en caso que queramos describir un comportamiento común para structs diferentes podremos hacer uso de <mark>trait</mark>, que viene a ser algo similar a lo que en otros lenguajes se denominan «interfaces». Todo esto se vé más claro con un ejemplo:</p><pre><code>// Podemos definir un struct para Persona<br />⁠//  con un nombre que podrá ser un String<br />⁠struct Persona {<br />  nombre: String,<br />⁠}<br />⁠<br />⁠// Igualmente podemos definir un struc para Gato<br />⁠//  también con un nombre String<br />⁠struct Gato {<br />  nombre: String,<br />⁠}<br />⁠<br />⁠// Cada ser vivo puede realizar ciertas acciones.<br />⁠//  Por ejemplo, presentarse<br />⁠trait SerVivoAcciones {<br />  fn presentarse(&amp;self);<br />⁠}<br />⁠<br />⁠// La persona puede presentarse verbalmente<br />⁠impl SerVivoAcciones for Persona {<br />  fn presentarse(&amp;self) {<br />    println!(&quot;- {}: Hola! Es un placer :)&quot;, &amp;self.nombre);<br />  }<br />⁠}<br />⁠<br />⁠// El gato también puede presentarse, pero… al estilo gatuno<br />⁠impl SerVivoAcciones for Gato {<br />  fn presentarse(&amp;self) {<br />    println!(&quot;- {}: Mrrrrr… Miaaou&quot;, &amp;self.nombre);<br />  }<br />⁠}<br />⁠<br />⁠// Podemos instanciar una Persona y un Gato<br />⁠//  y hacer que se presenten<br />⁠fn main() {<br />  let fulanito = Persona {<br />    nombre: String::from(&quot;Fulanito&quot;),<br />  };<br />  let minino = Gato {<br />    nombre: String::from(&quot;Minino&quot;),<br />  };<br />  fulanito.presentarse(); // - Fulanito: Hola! Es un placer :)<br />  minino.presentarse(); // - Minino: Mrrrrr… Miaaou<br />⁠}</code></pre><p class="centered" style="text-align: center"><figcaption>Sintaxis de Rust: <mark>struct</mark>, <mark>trait</mark>, and <mark>impl</mark>: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=fba7d06fa9fadb9f1f6105b45005b6b3" target="_blank">play.rust-lang.org</a>&nbsp;</figcaption></p><p>Este uso de <mark>structs</mark> en lugar de clases evita que escribamos estructuras muy anidadas, favoreciendo la composicion de elementos sobre las herencias. Rust nos permitirá escribir código tanto orientado a objetos como funcional, pero con ciertos límites en ambos casos. Es perfectamente posible usar patrones clásicos de programación orientada a objetos como la inyección de dependencias o funcionalidades como el polimorfismo, así como también lo es escribir código funcional con clausuras sin mutación de estado. Ambas aproximaciones encajan con naturalidad, aunque con algunas restricciones que nos inducirán a escribir estructuras más atómicas y legibles. El código resultante tendrá una sintaxis algo más compleja que en otros lenguajes, pero con estructuras  planas y sencillas que, al final, harán el código más fácil de leer y entender.</p><p>Rust se distribuye con una librería estándar que provee de diferentes funcionalidades. Entre ellas se encuentran las herramientas de threading, que nos permiten escribir programas concurrents. Esto, con la ayuda del compilador, el tipado estático, el verificador de préstamos y los punteros avanzados nos asegurarán que nuestros programas concurrentes serán seuros en cuanto a memoria se refiere, incluso en caso de multi-threading.</p><p>Una funcionalidad interesante de Rust es que no trae un tiempo de ejecución asíncrono integrado. Para disponer de uno vamos a tener que elegir e instalar uno externo: una opción bastante popular es Tokio, que se puede encontrar en el <a href="https://crates.io/crates/tokio" target="_blank">repositorio oficial de Rust</a>, aunque tenemos más opciones entre las que elegir.</p><p>Los tests se escriben con la suite que Rust trae integrada. Es posible escribir tanto tests unitarios para cada módulo como tests de integraciíon para toda la aplicación. Tiene unas funcionalidades muy concretas, pero muy claras y coherentes con la filosofía del lenguaje.</p><p>Trabajando con Rust viniendo de lenguajes tipo Java puede generar algo de confusión, pues hay un cambio de paradigma considerable; sin embargo, una vez que esta primera fase es superada, el lenguaje se escribe con asombrosa naturalidad. Tiene similitudes con C y C++, pero con una sintaxis muchísimo más limpia. Dadas las herramientas que nos ofrece para manejo de memoria y genéricos bien se podría describir Rust como «una versión declarativa de C».</p><p>---</p><h1>Rust en práctica</h1><p>Para demostrar cómo se podría estructurar un progama en Rust podemos vamos a crear una aplicación sencilla, simplemente para visualizar la sintaxis del lenguaje.</p><p>Podríamos, por ejemplo, escribir un programa al que pudieramos pedir una lista de usuarios que estuviera almacenada en algún tipo de base de datos, digamos que en PostgreSQL. Y además, queremos que nos dé esta lista en sentido inverso al que está en la base de datos.</p><p>De este modo nuestro programa tendría varios conceptos, a saber:</p><ul><li>Un usuario <mark>User</mark>, que sería el modelo: un <mark>struct</mark>.</li><li>El proceso de invertir la lista, que correspondería a la lógica de negocio: esto sería un «caso de uso», que podríamos escribir en un <mark>struct</mark>. Este caso de uso utilizará el módulo que escribamos para recoger los datos de la base de datos, el cual tendrá que cumplir con un <mark>trait</mark> que vamos a describir en el siguiente punto. </li><li>Y finalmente, el sistema para recoger los datos de la base de datos en PostgreSQL, que será otro <mark>struct.</mark> Para evitar acoplar el caso de uso con el repositorio de PostgreSQL escribiremos un <mark>trait</mark> con la descripción general de nuestro <mark>struct</mark> para la base de datos, y que le pasaremos al caso de uso. Así, cualquier repositorio que queramos utilizar con nuestro caso de uso tendrá que cumplir con el <mark>trait</mark>, desacoplando el caso del uso del repositorio y haciendo más fácil cambiar de PostgreSQL a otro tipo de base de datos en el futuro.</li></ul><img src="https://www.dev.antoniodiaz.me:3000/media/files/e4e2bb46-c210-4a47-9e84-f45c789fcec1/articles/original/703eeb33-5a23-404a-85ec-a4841857abc2.png" data-ratio="0.47" /><p class="centered" style="text-align: center"><figcaption>Estructura de nuestra aplicación</figcaption></p><p>Ahora que nos hemos hecho una idea de cómo deberíaser nuestra aplicación, vamos a implementarla. Omitiremos alguna línea de código necesaria para que nuestro programa complile, pero el ejemplo completo se puede ver en el playground oficial de Rust: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=22e033ec941fbc7cab591ce88b56c9f0" target="_blank">play.rust-lang.org</a>.</p><p>Primero, vamos a crear nuestra entidad o modelo: un usuario <mark>User</mark> con un campo <mark>id</mark>:</p><pre><code>pub struct User {<br />  pub id: i8,<br />⁠}</code></pre><p class="centered" style="text-align: center"><figcaption> Struct para nuestro modelo <mark>User</mark></figcaption></p><p>Ahora que tenemos nuestro modelo principal —un <mark>struct</mark>—, la siguiente cuestión es qué queremos hacer con él. En otras palabras: queremos definir el caso de uso para recoger la lista de usuarios en sentido inverso. Sabemos que este caso de uso tendrá que tener una instancia del repositorio para recoger los datos de la base de datos, pero no sabemos todavía el <em>tipo</em> del repositorio: esto es una tarea para un tipo genérico:</p><pre><code>struct GetUsersRevertedUseCase&lt;T&gt; {<br />  repository: T,<br />⁠}</code></pre><p class="centered" style="text-align: center"><figcaption> Struct para nuestro caso de uso <mark>GetUsersRevertedUseCase</mark></figcaption></p><p>Nuestro caso de uso —también un <mark>struct</mark>— infiere el tipo del repositorio cuando se la pasamos al instanciarlo. Pero un <mark>struct</mark> no define acciones, y nuestro caso de uso precisamente tiene que realizar las acciones definidas por la lógica de negocio de nuestro programa. Como decíamos anteriormente, esto lo haremos implementando los métodos necesarios con el término <mark>impl</mark>:</p><pre><code>impl&lt;T: Repository&gt; GetUsersRevertedUseCase&lt;T&gt; {<br />  fn new(repository: T) -&gt; GetUsersRevertedUseCase&lt;T&gt; {<br />    GetUsersRevertedUseCase { repository }<br />  }<br />⁠}</code></pre><p class="centered" style="text-align: center"><figcaption> Implementando <mark>new</mark> para nuestro caso de uso</figcaption></p><p>Digno de mención aquí es la sintaxis <mark>&lt;T: Repository&gt;</mark>. Con esto le estamos diciendo al compliador que <mark>T</mark> puede ser cualquier <mark>struct</mark> implementando el <mark>trait</mark>&nbsp;<mark>Repository</mark>, devolviendo un error si pasamos cualquier otro tipo de instancia. Además, hemos añadido un método <mark>new</mark>  que devuelve una instancia de sí mismo pero con la instancia del repositorio en su interior. Así que ya tenemos nuestro caso de uso con la capacidad de recibir un repositorio, siempre que este cumpla con los requerimientos de un determinado <mark>trait</mark>, el cual tenemos pendiente.</p><p>Veamos cómo podemos definir el tipo de repositorio que necesitamos. Sabemos que tiene que realizar una acción asíncrona —recoger datos de una base de datos—, y que tiene que devolver los datos que ha recibido —una lista de usuarios—. Podemos escribir un <mark>trait</mark> con estas especificaciones de la siguiente manera:</p><pre><code>trait Repository {<br />  async fn get_users(&amp;self) -&gt; Result&lt;Vec&lt;User&gt;, String&gt;;<br />⁠}</code></pre><p class="centered" style="text-align: center"><figcaption> Trait para nuestros repositorios</figcaption></p><p>Hay algunas cosas nuevas aquí: primero, el término <mark>async</mark>, el cual hace que nuestra fución devuelva un tipo <mark>Result</mark>. Este tipo es una de las particularidades de Rust: representa el resultado de una acción que puede tener éxito —<mark>Ok(T)</mark>— o sufrir un error —<mark>Err(K)</mark>—. En nuestro caso, si la acción definida por nuestro método tiene éxito, tendrá como resultado <mark>Ok&lt;Vec&lt;User&gt;&gt;</mark>, esto es, una lista de ususarios <mark>User</mark>; por el contrario, si nuestra acción fracasa, devolverá <mark>Err(String)</mark>. Para no liarnos mucho no vamos a implementar ningún error, pero el tipo <mark>Result</mark> nos obliga a tener esta posibilidad en consideración, puesto que estamos escribiendo código asíncrono. Esto es una de las ventajas de Rust: no nos deja ser perezosos con los tipos.</p><p>Ahora podemos pensar en cómo podemos lanzar nuestro caso de uso, para lo cual podemos añadirle un método <mark>execute</mark>.</p><pre><code>impl&lt;T: Repository&gt; GetUsersRevertedUseCase&lt;T&gt; {<br />  […]<br />  async fn execute(&amp;self) -&gt; Result&lt;Vec&lt;User&gt;, String&gt; {<br />    let users = self.repository.get_users().await.unwrap();<br />    let reverted_users: Vec&lt;User&gt; = users.into_iter().rev().collect();<br />    Ok(reverted_users)<br />  }<br />⁠}</code></pre><p class="centered" style="text-align: center"><figcaption> Implementando <mark>execute</mark> para nuestro caso de uso</figcaption></p><p>Ah, el término <mark>async</mark> otra vez, esta vez para esperar a que la acción de nuestro repositorio termine. También está el tipo <mark>Result</mark>, esto empieza a ser familiar.</p><p>Como nuestro repositorio está devolviendo un tipo <mark>Result</mark> —<mark>Ok&lt;T&gt;</mark> o <mark>Err&lt;K&gt;</mark>—, necesitamos extraer el valor —la lista de usuarios— de nuestro <mark>Ok&lt;T&gt;</mark> para trabajar con ella. Esto lo hacemos con la función <mark>unwrap()</mark>, que nos devuelve el valor <mark>T</mark> —nuestra lista de usuarios— si estamos en un <mark>Ok</mark>, o devolviendo un error si fracasa.</p><p>Además tenemos algunas funciones operando sobre nuestra lista de usuarios para invertirla: <mark>into_iter</mark>, que convierte un vector en una lista de elementos que podamos iterar; <mark>rev</mark>, que invierte una lista de elementos iterable, y <mark>collect</mark>, que convierte una lista iterable de nuevo en un vector. Estas funcionalidades pertenecen todas al tipo <mark>Vec</mark>, que está integrado en Rust para manipular vectores al estilo funcional.</p><p>Vale, ahora ya tenemos nuestro modelo, nuestro caso de uso, y un trait para cualquier repositorio que queramos pasarle. El siguiente paso será crear nuestro repositorio para el tipo concreto de base de datos que queramos utilizar: PostgreSQL:</p><pre><code>impl Repository for PostgreSQLRepository {<br />  async fn get_users(&amp;self) -&gt; Result&lt;Vec&lt;User&gt;, String&gt; {<br />⁠    let duration_secs = Duration::from_secs(2);<br />⁠    sleep(duration_secs);<br />⁠    let user_1 = User { id: 1 };<br />⁠    let user_2 = User { id: 2 };<br />⁠    Ok(vec![user_1, user_2])<br />⁠  }<br />⁠}</code></pre><p class="centered" style="text-align: center"><figcaption> Struct <mark>PostgreSQLRepository</mark></figcaption></p><p>Como esto es sólo una demostración simplemente vamos a simular que vamos a recoger datos de manera asíncrona de nuestra supuesta base de datos. Para ello usaremos dos métodos de la librería estándar: <mark>sleep</mark> y <mark>Duration</mark>. <mark>Duration</mark> devuelve un tipo específico de tiempo, que le podremos pasar a otros métodos, como por ejemplo <mark>sleep</mark>. Y <mark>sleep</mark> simplemente detendrá la ejecución del programa por el tiempo que le hayamos pasado. En nuestro caso estamos deteniendo nuestro programa por dos segundos, entonces instanciamos dos usuarios, y finalmente estamos devolviendo un <mark>Vector</mark> con ellos.</p><p>Ahora disponemos ya de todos los elementos necesarios para nuestro programa: el modelo <mark>User</mark>, el caso de uso <mark>GetUsersRevertedUseCase</mark>, el <mark>trait</mark>&nbsp;<mark>Repository</mark> y el <mark>struct</mark>&nbsp;<mark>PostgreSQLRepository</mark> que lo implementa. Sólo nos falta crear un punto de entrada para nuestro programa y hacer uso de ellos.</p><pre><code>#[tokio::main]<br />⁠async fn main() {<br />⁠  let repository = PostgreSQLRepository;<br />⁠  let use_case = GetUsersRevertedUseCase::new(repository);<br />⁠  let users = use_case.execute().await.unwrap();<br />⁠  println!(&quot;{:#?}&quot;, users);<br />⁠}</code></pre><p class="centered" style="text-align: center"><figcaption>Punto de entrada de nuestro programa</figcaption></p><p>Como queremos ejecutar código asíncrono necesitaremos traer un tiempo de ejecución que nos lo facilite: vamos a usar Tokio, así que podemos llamar al macro <mark>#[tokio:main]</mark>. </p><p>Después no tenemos más que crear una instancia de nuestro repositorio, construir nuestro caso de uso pasándole la instancia que acabamos de crear, y ejecutarla, esperándola con <mark>await</mark>. El resultado será una lista de usuarios en sentido inverso.</p><pre><code>[<br />⁠  User {<br />⁠    id: 2,<br />⁠  },<br />⁠  User {<br />⁠    id: 1,<br />⁠  },<br />⁠]</code></pre><p class="centered" style="text-align: center"><figcaption>Resultado: lista de usuarios en sentido inverso</figcaption></p><p>Podemos ver este código completo en el playground de Rust: <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=22e033ec941fbc7cab591ce88b56c9f0" target="_blank">play.rust-lang.org</a>, donde podemos compilarlo y ejecutarlo.</p><h1>Conclusión</h1><p>Rust no es un lenguaje sencillo. Exige estudio y bastante paciencia para entender su sintaxis y las funcionalidades que nos ofrece. Además es muy joven, y su ecositema está en constante evolución. Pero promete.</p><p>Es en tareas que requieren eficiencia donde el lenguaje encaja perfectamente. Para desarrollo web en términos generales, donde la velocidad de prototipado y se requieren dinámicas de trabajo <em>agile</em> son importantes, lenguajes interpretados como Python o TypeScript encajan mejor. Pero cuando pérdidas de memoria puedan provocar repuntes o problemas de eficiencia en uso de servidores, Rust es una opción mucho mejor.</p><p>La aceptación actual de Rust en la industria es muy limitada, pero la Rust Foundatio es soportada por Google, Microsoft, AWS, Huawei y Mozilla; además hay una clara demanda para lenguajes enfocados a eficiencia, y probablemente veremos cómo logra introducirse en los próximos años. </p><p>En cualquier caso hay numerosas dificultades: las empresas que dan soporte a Rust intentarán <a href="https://news.ycombinator.com/item?id=28513130" target="_blank">influenciar sobre su desarrollo</a>&nbsp;<a href="https://news.ycombinator.com/item?id=28513130" target="_blank">&nbsp;</a>para que evolucione según sus necesidades particulares, y hay claros <a href="https://blog.rust-lang.org/inside-rust/2021/11/25/in-response-to-the-moderation-team-resignation.html" target="_blank">desacuerdos</a> entre el equipo interno. Pero el lenguaje encaja tan bien en las tareas que hemos mencionado que sería interesante seguir su evolución e integración en la industria.</p><p>Para concluir: Rust es un lenguaje complejo, pero es posible y claramente deseable usar Rust en contextos específicos donde performance y seguridad es un requerimiento.</p></p>]]></description></item></channel></rss>